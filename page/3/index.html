<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>KyleCe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="KyleCe">
<meta property="og:url" content="https://github.com/KyleCe/kylece.github.io/page/3/index.html">
<meta property="og:site_name" content="KyleCe">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KyleCe">
  
    <link rel="alternate" href="/atom.xml" title="KyleCe" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/avatar.jpg">
  <link rel="apple-touch-icon" href="/css/images/avatar.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/home.css" >
  

  

  

  
  
  

</head>



  <body>


  
    <header id="header">

	<!-- 背景图模式 -->
	

    
      <div id="intrologo" class="intro-logo" style="background-position:center; background-repeat:no-repeat; background-image: url(); background-size: auto 100%;">

      <!-- Support rolling -->  
        
        <section class="awSlider">
          <div class="carousel slide carousel-fade " data-ride="carousel">

            <!-- Wrapper for slides -->
            <div class="carousel-inner">
               
                  
                    <div class="item active">
                  
                    <img id="carousel-img0" src="/css/images/home-bg.jpg">
                  </div>

                  <!-- 自适应大图 -->
                  <script>
                      var img0 = new Image();
                      var imageTag0 = document.getElementById("carousel-img0");
                      img0.src = imageTag0.src;
                      img0.onload=function(){
                        if (img0.width / img0.height <= document.body.clientWidth / document.body.clientHeight) {
                          imageTag0.style.width = document.body.clientWidth + "px";
                        } else {
                          imageTag0.style.height = document.body.clientHeight + "px";
                          imageTag0.style.marginLeft = -(document.body.clientHeight * img0.width / img0.height - document.body.clientWidth) / 2 + "px";
                        }
                      };
                  </script>
                
                  
                    <div class="item">
                  
                    <img id="carousel-img1" src="/css/images/sample.jpg">
                  </div>

                  <!-- 自适应大图 -->
                  <script>
                      var img1 = new Image();
                      var imageTag1 = document.getElementById("carousel-img1");
                      img1.src = imageTag1.src;
                      img1.onload=function(){
                        if (img1.width / img1.height <= document.body.clientWidth / document.body.clientHeight) {
                          imageTag1.style.width = document.body.clientWidth + "px";
                        } else {
                          imageTag1.style.height = document.body.clientHeight + "px";
                          imageTag1.style.marginLeft = -(document.body.clientHeight * img1.width / img1.height - document.body.clientWidth) / 2 + "px";
                        }
                      };
                  </script>
                
                  
                    <div class="item">
                  
                    <img id="carousel-img2" src="https://source.unsplash.com/collection/954550/1920x1080">
                  </div>

                  <!-- 自适应大图 -->
                  <script>
                      var img2 = new Image();
                      var imageTag2 = document.getElementById("carousel-img2");
                      img2.src = imageTag2.src;
                      img2.onload=function(){
                        if (img2.width / img2.height <= document.body.clientWidth / document.body.clientHeight) {
                          imageTag2.style.width = document.body.clientWidth + "px";
                        } else {
                          imageTag2.style.height = document.body.clientHeight + "px";
                          imageTag2.style.marginLeft = -(document.body.clientHeight * img2.width / img2.height - document.body.clientWidth) / 2 + "px";
                        }
                      };
                  </script>
                
            </div>

            <!-- Controls -->
            <a class="left carousel-control" href=".carousel" role="button" data-slide="prev">
              <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
              <span class="sr-only">Geri</span>
            </a>
            <a class="right carousel-control" href=".carousel" role="button" data-slide="next">
              <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
              <span class="sr-only">İleri</span>
            </a>
          </div>
        </section>
        <script>
          $('section.awSlider .carousel').carousel({
              pause: '',
              interval: 5000
          });
          var startImage = $('section.awSlider .item.active > img').attr('src');
          $('section.awSlider .carousel').on('slid.bs.carousel', function () {
              var bscn = $(this).find('.item.active > img').attr('src');
              $('section.awSlider > img').attr('src', bscn);
          });
        </script>
      

    
 


    <canvas width="100%" height="100%"></canvas>
    <script>
      var c = document.getElementsByTagName('canvas')[0],
          x = c.getContext('2d'),
          w = window.innerWidth,
          h = window.innerHeight,
          pr = window.devicePixelRatio || 1,
          f = 90,
          q,
          m = Math,
          r = 0,
          u = m.PI*2,
          v = m.cos,
          z = m.random
      c.width = w*pr
      c.height = h*pr
      x.scale(pr, pr)
      x.globalAlpha = 0.6

      <!-- 折线Polyline背景 -->
      
    </script>
    

    
      <div id="homelogo" class="homelogo" style="background: rgba(255,255,255,1);"> 
    

        
          <div class="homelogoback"  style="border: 1px solid #404040;" >
            <h1><a href="#content" id="logo">KyleCe</a></h1>
            <h3></h3>
            <h5>KyleCe</h5>
            <!-- <p><a href="https://github.com/iTimeTraveler" target="_blank">Github</a></p> -->
          </div>
        
    
    </div>
  </div>

  <!-- 自适应主页背景大图 -->
  

 <!-- home_logo_image居中 -->
 
    <script>
        var homelogodiv = document.getElementById("homelogo");
        if (document.all.homelogo.offsetWidth > document.body.clientWidth) {
          homelogodiv.style.width = document.body.clientWidth + "px";
          homelogodiv.style.marginLeft = document.body.clientWidth * -0.5 + "px";
        } else {
          homelogodiv.style.width = homelogodiv.clientWidth  + "px";
          homelogodiv.style.marginLeft = (homelogodiv.clientWidth)  * -0.5 + "px";
        }
    </script>
  

  <div class="intro-navigate">
      <p class="navigater-list">
        
          <a id="beautifont" class="main-nav-link" href="/">首页</a>
        
          <a id="beautifont" class="main-nav-link" href="/archives">归档</a>
        
          <a id="beautifont" class="main-nav-link" href="/categories">分类</a>
        
          <a id="beautifont" class="main-nav-link" href="/tags">标签</a>
        
          <a id="beautifont" class="main-nav-link" href="/about">关于</a>
        
      </p>
  </div>

</header>
  
  <div id="container">
    <div id="wrap">
      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;">
  
    <article id="post-技术/程序/Java进阶-- 以函数对象代表策略"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/03/09/技术/程序/Java进阶-- 以函数对象代表策略/">Java进阶-- 以函数对象代表策略</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/03/09/技术/程序/Java进阶-- 以函数对象代表策略/" class="article-date">
	  <time datetime="2018-03-08T16:35:35.000Z" itemprop="datePublished">2018-03-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/技术/">技术</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="摘要与关键字"><a href="#摘要与关键字" class="headerlink" title="摘要与关键字"></a>摘要与关键字</h3><p>介绍设计模式中的策略模式（strategy）</p>
<p>C++、C语言中的函数指针在Java中的替代形式</p>
<p>面向接口编程</p>
<p>keywords：</p>
<p><strong>策略、函数对象、面向接口</strong></p>
<h3 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h3><p>函数指针，或是实现代理模式、lambda表达式</p>
<p>### </p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-技术/程序/Java进阶-- 优先考虑泛型方法"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/03/09/技术/程序/Java进阶-- 优先考虑泛型方法/">Java进阶-- 优先考虑泛型方法</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/03/09/技术/程序/Java进阶-- 优先考虑泛型方法/" class="article-date">
	  <time datetime="2018-03-08T16:35:35.000Z" itemprop="datePublished">2018-03-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/技术/">技术</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>类可以从泛型中受益，静态工具API更适合泛型</p>
<blockquote>
<p>Collections 的算法方法都已泛型化(如binarySearch、sort)</p>
</blockquote>
<h3 id="优势示例"><a href="#优势示例" class="headerlink" title="优势示例"></a>优势示例</h3><ul>
<li>例1：精简API</li>
</ul>
<p><img src="../../pic_resource/GenericMethodEg.png" alt=""></p>
<p>代码所示是一个简单的设置字体的Util的static API的泛型化代码；</p>
<p>如果不是使用这种泛型化的API，则需要为TextView的扩展类（Button、CheckBox等等）编写数不清的函数</p>
<ul>
<li>例2：确保类型安全的情况下提升API的易用性</li>
</ul>
<p><img src="../../pic_resource/GenericMethodEg2.png" alt=""></p>
<p>可以看到上面的API可以轻易的操作所有以View为基类的类的集合；</p>
<ul>
<li>例3：类级别的泛型化</li>
</ul>
<p><img src="../../pic_resource/GenericMethodEgClass.png" alt=""></p>
<blockquote>
<p>在配合集合使用时需要注意类型cast的警告，这些警告实际上是编译时不会有问题，但真正在运行时可能会抛出ClassCastException，我们在实际项目中应该将这些潜在的威胁清除掉；</p>
<p>对于十分确定不会出问题的类型操作API上，可以用@SuppressWarning(“unckecked”)消除这类警告</p>
</blockquote>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>赶紧用起来吧，你的小伙伴会爱上你写的极简API的</p>
<blockquote>
<p>源码里的代码有很多写的极好的点，同学们平时可以扒一扒</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-技术/程序/Java进阶-- volatile关键字"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/03/09/技术/程序/Java进阶-- volatile关键字/">Java进阶-- volatile关键字</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/03/09/技术/程序/Java进阶-- volatile关键字/" class="article-date">
	  <time datetime="2018-03-08T16:35:35.000Z" itemprop="datePublished">2018-03-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/技术/">技术</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>volatile含有部分synchronized的特性，效率更高，但使用时需要注意细节，不然容易出错</p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Java中被volatile修饰的变量，每次读写都会直接使用“内存”介质，而不是使用CPU缓存</p>
<blockquote>
<p>音 — UK <strong> /ˈvɒl.ə.taɪl/  US </strong> /ˈvɑː.lə.t̬əl/</p>
<p>英 — <strong>likely to change suddenly and unexpectedly or suddenly become violent or angry</strong></p>
<p>中 — 易变的</p>
</blockquote>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>保证变量可见性</li>
<li>禁止指令进行重排序</li>
</ul>
<blockquote>
<p>基础概念：可见性、有序性、原子性</p>
<ol>
<li>可见性：对所有线程来说，任一线程对变量的改动都立即可见</li>
<li>有序性：代码可能会被编译器混编，有序性即指代码按顺序执行</li>
<li>原子性：所有操作不会被打断，谁也不行（除非断电）</li>
</ol>
</blockquote>
<p>实际上我们对变量的修改，虽然可能Java就一行代码（如 y=x），但被解释成汇编语言会变成多行（y=x就需要进行两步操作：读x值，写入y所在内存，学过汇编的同学应该比较清楚）</p>
<h3 id="与synchronized的区别"><a href="#与synchronized的区别" class="headerlink" title="与synchronized的区别"></a>与synchronized的区别</h3><p>按字面理解，volatile关键字只是标记变量为易变的，并不能保证对变量的所有操作都是同步的，即不能保证具有synchronized一样的效果</p>
<p>实际上，对volatile修饰的变量的读/写操作是可以保证其原子性的，但还要注意一个问题，即同时写变量的线程可能不止一个，如此一来，其中部分的写操作就有可能丢失</p>
<p>听起来好像volatile使用起来很危险，但它也是有它的用途的</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul>
<li>对于写不依赖历史状态的变量，可以考虑使用volatile修饰字代替synchronized来提高程序效率</li>
<li>保证代码的有序性：volatile变量的读写操作之前的代码，编译器是不会进行重排序的</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在volatile满足不了要求的场景可以考虑使用synchronized、lock、Atomic变量来保证特性</p>
<p>对变量的写不依赖历史状态的变量使用volatile修饰可以提高效率</p>
<p>对于需要保证部分程序语句有序性的场景可以考虑使用volatile代替锁定整个代码块，提高效率</p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volatile/">volatile</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-技术/Android/由 Java GC 看 Android 内存泄露"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/03/09/技术/Android/由 Java GC 看 Android 内存泄露/">由 Java GC 看 Android 内存泄露</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/03/09/技术/Android/由 Java GC 看 Android 内存泄露/" class="article-date">
	  <time datetime="2018-03-08T16:35:35.000Z" itemprop="datePublished">2018-03-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/技术/">技术</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="由-Java-GC-看-Android-内存泄露"><a href="#由-Java-GC-看-Android-内存泄露" class="headerlink" title="由 Java GC 看 Android 内存泄露"></a>由 <em>Java GC</em> 看 <em>Android</em> 内存泄露</h1><blockquote>
<p><strong>标题</strong>：<em>《由 Java GC 看 Android 内存泄露》</em><br><strong>作者</strong>：<em>KyleCe</em><br><strong>关键词</strong>：<em>JavaGC、Android、内存泄露</em></p>
<p>@Email: <a href="mailto:chengong90@gmail.com" target="_blank" rel="noopener">chengong90@gmail.com</a><br>@date: 2017年07月31日</p>
</blockquote>
<p>内存泄露，一个老生常谈的话题，本文将从Java GC的角度出发，着眼JavaGC收集器，一探Android内存泄露的究竟，最后总结实战经验，希望能给读者带来些许启发。</p>
<p><em>本篇涵盖：</em></p>
<ul>
<li><em><strong>准备</strong>——基础知识要求及名字解释</em></li>
<li><em><strong>背景</strong>——Android内存泄露的本质与危害</em></li>
<li><em><strong>原因</strong>——为什么会产生泄露</em></li>
<li><em><strong>基础</strong>——Java内存分配与回收</em></li>
<li><em><strong>引申</strong>——JVM与Android虚拟机</em></li>
<li><em><strong>实战</strong>——内存泄露攻防</em></li>
</ul>
<h2 id="零、准备"><a href="#零、准备" class="headerlink" title="零、准备"></a>零、准备</h2><h3 id="0-0-要求："><a href="#0-0-要求：" class="headerlink" title="0.0 要求："></a>0.0 要求：</h3><p>  阅读本文，需要读者具有一定的JAVA基础与Android基础</p>
<h3 id="0-1-名词解释："><a href="#0-1-名词解释：" class="headerlink" title="0.1 名词解释："></a>0.1 名词解释：</h3><ul>
<li>GC——Garbage Collector垃圾收集器</li>
<li>MAT——Eclipse  Memory Analyzer Tool 内存分析工具</li>
<li>LeakCanary——第三方内存泄露监测工具</li>
<li>StrictMode——Android严格模式，调优时可以参考</li>
<li>HotSpot——Sun公司开发的Java虚拟机类别，现属Oracle</li>
<li>堆、栈——Heap、Stack，一般指内存堆，方法栈</li>
<li>finalize——Object在被GC回收时可能会被调用的方法</li>
<li>GC Roots——GC引用路径，通常有好几种类别，是一个集合</li>
<li>StrongReference/SoftReference/WeakReference/PhantomReference——强/弱/软/虚引用</li>
<li>STW——StopTheWorld GC时需要暂停所有用户线程</li>
<li>SafePoint &amp; SafeRegion——安全点/安全区，分别为内存/线程在GC 欲Stop The World时可以停留的点</li>
<li>OopMap——Ordinary Object Pointer Map，HotSpot实现准备式GC的基础</li>
<li>年轻代、老年代、永久代、MetaSpace</li>
<li>Eden/Survivor——年轻代的区域划分</li>
<li>MinorGC &amp; FullGC/MajorGC——轻量GC/Full GC</li>
<li>Age——对象年龄，每活过一次GC，Age+1</li>
<li>JVM/DVM/ART——Java虚拟机/Android Dalvik/ Android Runtime</li>
</ul>
<h3 id="0-2-演示环境："><a href="#0-2-演示环境：" class="headerlink" title="0.2 演示环境："></a>0.2 演示环境：</h3><ul>
<li>Android Studio——3.0 Canary 8</li>
<li>Eclipse MAT——V1.7.0</li>
<li>LeakCanary——V1.5.1</li>
<li>HotSpot——Java Hotspot JVM(SE6/7)</li>
</ul>
<h2 id="一、本质与危害"><a href="#一、本质与危害" class="headerlink" title="一、本质与危害"></a>一、本质与危害</h2><h3 id="1-1-何谓内存泄露"><a href="#1-1-何谓内存泄露" class="headerlink" title="1.1 何谓内存泄露"></a>1.1 何谓内存泄露</h3><p>在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p>
<p>在安卓中，内存泄露主要是指应用程序进程在运行过程中有不能释放而不再使用的内存，占用了比实际需要多的空间。</p>
<p>图1.1.1是使用MAT分析手机内存快照得到的OverView结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-ca4c6177eb55ae69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图1.1.1 ORG某款应用的Debug版内存泄露OverView"></p>
<p>图1.1.1 ORG某款应用的Debug版内存泄露OverView</p>
<h3 id="1-2-恶劣影响"><a href="#1-2-恶劣影响" class="headerlink" title="1.2 恶劣影响"></a>1.2 恶劣影响</h3><p>内存泄漏会因为减少可用内存的数量从而降低计算机的性能。最终，在最糟糕的情况下，过多的可用内存被分配掉导致全部或部分设备停止正常工作，或者应用程序崩溃。在以下情況，内存泄漏导致较嚴重的后果：</p>
<ul>
<li>程序运行后置之不理，消耗越来越多的内存（比如服务器上的后台任务，尤其是嵌入式系统中的后台任务，这些任务可能被运行后很多年内都置之不理）；</li>
<li>频繁分配新内存；</li>
<li>程序能够请求未被释放的内存（比如共享内存）；</li>
<li>内存非常有限，比如在嵌入式系统或便携设备中；</li>
<li>…</li>
</ul>
<p>针对安卓，内存泄露轻则导致应用占用内存虚高、增加CPU占用、耗电，重则导致应用程序无法开辟所需大小的内存，引发OOM，触发崩溃，这在内存小的机器上尤为明显（我们平时在测试应用内存占用表现时，可以多使用低端机）。<br>结合上一节所举例子，由图1.1.1可见该应用的泄露足有35M之多，这一内存结果还是应用刚启动时的情况，随着用户使用时间加长，泄露只会越来越多，直到用户杀死应用或者应用主动崩溃（如图1.2.1）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-b460f38cafbd927b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图1.2.1 AndroidStudio 某OutOfMemory 堆栈"></p>
<p>图1.2.1 AndroidStudio 某OutOfMemory 堆栈</p>
<h2 id="二、产生缘由"><a href="#二、产生缘由" class="headerlink" title="二、产生缘由"></a>二、产生缘由</h2><p>内存泄露诱因有很多，安卓中比较常见的有：</p>
<ul>
<li>静态变量持有引用(集合类、单例造成的内存泄漏)</li>
<li>匿名内部类/非静态内部类和异步线程</li>
<li>Handler 、UI线程的post、AnimatorListener等使用不当</li>
<li>资源未关闭(或在finalize中关闭)</li>
<li>监听器的使用，在释放对象的同时没有相应删除监听器</li>
<li>…</li>
</ul>
<p>下面针对部分诱因进行说明，具体解决办法此处按下不表。</p>
<h3 id="2-1-静态变量导致的泄露"><a href="#2-1-静态变量导致的泄露" class="headerlink" title="2.1 静态变量导致的泄露"></a>2.1 静态变量导致的泄露</h3><p>静态集合导致的泄露可以分析为：长生命周期的对象，持有了短生命周期对象的引用，在后者生命周期结束时未释放长周期对象对它的引用，导致对象无法被GC回收。</p>
<p>以如下代码为示例：即使在循环内有设置集合对象为null，但集合中的对象还是存在，GC并不能回收它（这种在集合中不断创建新对象的写法也是极其臭名昭著的）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleUnitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector sVector = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            Object o = <span class="keyword">new</span> Object();</span><br><span class="line">            sVector.add(o);</span><br><span class="line">            o = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图2.1为某APP静态集合泄露的对象汇总，可以看到总大小有11.7M之大。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-5a2e015b3d5de3b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/h/600" alt="图2.1 某静态泄露的汇总结果"></p>
<p>图2.1 某静态泄露的汇总结果</p>
<h3 id="2-2-匿名内部类引发的内存泄露"><a href="#2-2-匿名内部类引发的内存泄露" class="headerlink" title="2.2 匿名内部类引发的内存泄露"></a>2.2 匿名内部类引发的内存泄露</h3><p>匿名内部类极易引发内存泄露，纵使这样的写法在代码层面会简洁很多，但在涉及到匿名内部类生命周期不依附于外部类时，需要我们谨慎处理，不然就很有可能引发泄露。</p>
<p>如下代码为AppsFlayer SDK 4.7.1 Foreground.java中某段代码的近似版本（该泄露在SDK v4.7.4中已修复，图2.2.1 为两版本代码的对比图，中间截图为监测工具上报的泄露路径）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">async</span><span class="params">(<span class="keyword">final</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> AsyncTask&lt;Void, Void, Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException var4) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                WeakReference&lt;Activity&gt; weakActivity = <span class="keyword">new</span> WeakReference(activity);</span><br><span class="line">                weakActivity.get().setContentView(<span class="keyword">null</span>);</span><br><span class="line">                weakActivity.clear();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">                <span class="keyword">this</span>.cancel(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-783169a523910316.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图2.2.1 AppsFlyer leak and resolution"></p>
<p>图2.2.1 AppsFlyer leak and resolution</p>
<p>如下代码展示了常见的Handler写法可能引发的内存泄露：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!onMessage(msg)) &#123;</span><br><span class="line">			<span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如下代码展示了内部类持有外部类的成员变量，存在泄露隐患<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageContext</span> <span class="keyword">implements</span> <span class="title">ThemeDataManager</span>.<span class="title">Context</span>&lt;<span class="title">Pair</span>&lt;<span class="title">String</span>, <span class="title">Bitmap</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSucc</span><span class="params">(<span class="keyword">final</span> JSONObject extendData, Pair&lt;String, Bitmap&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCoverView.setImageBitmap(p.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(<span class="keyword">final</span> JSONObject extendData, <span class="keyword">int</span> result</span></span></span><br><span class="line"><span class="function"><span class="params">                                    , Pair&lt;String, Bitmap&gt; cache)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般在一个质量欠佳的工程中，匿名内部类或异步线程操作导致的内存泄露随处可见。</p>
<h3 id="2-3-Handler任务管理不当"><a href="#2-3-Handler任务管理不当" class="headerlink" title="2.3 Handler任务管理不当"></a>2.3 Handler任务管理不当</h3><p>Handler、AnimationListener、AnimatorUpdateListener使用不当也极易导致泄露:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(TAG + TAG + <span class="string">"  running"</span> + parent);</span><br><span class="line">        mHandler.postDelayed(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-资源未及时关闭"><a href="#2-4-资源未及时关闭" class="headerlink" title="2.4 资源未及时关闭"></a>2.4 资源未及时关闭</h3><p>Android资源不及时关闭会出现内存泄露的地方有很多，诸如在使用I/O流、Cursor（图2.4.1展示了在APP开启StrictMode时会收到的FileIO未close的异常Throwable）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-cbf5aa5529865f5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图2.4.1 closable close未调用"></p>
<p>图2.4.1 closable close未调用</p>
<h3 id="2-5-绑定-解绑、注册-反注册未成对调用"><a href="#2-5-绑定-解绑、注册-反注册未成对调用" class="headerlink" title="2.5 绑定/解绑、注册/反注册未成对调用"></a>2.5 绑定/解绑、注册/反注册未成对调用</h3><p>绑定/解绑、注册/反注册同时出现这一点毋庸置疑，但实际工程中发现有开发者对于成对调用的理解不够透彻，会有前后条件不一致的情况，导致内存泄露（如注册时无条件注册，反注册时加入不能100%保证成立的判定条件）</p>
<h2 id="三、Java内存分配与垃圾回收策略"><a href="#三、Java内存分配与垃圾回收策略" class="headerlink" title="三、Java内存分配与垃圾回收策略"></a>三、Java内存分配与垃圾回收策略</h2><h3 id="3-0-虚拟机架构（HotSpot）"><a href="#3-0-虚拟机架构（HotSpot）" class="headerlink" title="3.0 虚拟机架构（HotSpot）"></a>3.0 虚拟机架构（HotSpot）</h3><p>图3.0.1为HotSpot虚拟机架构，具体的划分将在下文中描述，这里只需要了解大致概念。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-1bf9a615abb8e4d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.0.1 HotSpot Structure"></p>
<p>图3.0.1 HotSpot Structure</p>
<p>本文所谈论的GC，处理的内存区块针对的主要是虚拟机的Heap，亦即堆。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-7061db0196475abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.0.2 HotSpot JVM components"></p>
<p>图3.0.2 HotSpot JVM components</p>
<h3 id="3-1-内存分配"><a href="#3-1-内存分配" class="headerlink" title="3.1 内存分配"></a>3.1 内存分配</h3><h4 id="3-1-1-对象生命周期"><a href="#3-1-1-对象生命周期" class="headerlink" title="3.1.1 对象生命周期"></a>3.1.1 对象生命周期</h4><ul>
<li>至少两次标记——一次标记、筛选是否finalize</li>
<li>finalize()——不承诺完成、一次机会、不承诺调 用顺序——避免无良操作引发JVM崩溃</li>
</ul>
<h4 id="3-1-2-引用计数收集器"><a href="#3-1-2-引用计数收集器" class="headerlink" title="3.1.2 引用计数收集器"></a>3.1.2 引用计数收集器</h4><ul>
<li>为对象添加引用计数器</li>
<li>弊端:无法解决对象相互循环引用的问题</li>
</ul>
<h4 id="3-1-3-可达性分析（Reachability-Analysis）"><a href="#3-1-3-可达性分析（Reachability-Analysis）" class="headerlink" title="3.1.3 可达性分析（Reachability Analysis）"></a>3.1.3 可达性分析（Reachability Analysis）</h4><ul>
<li>GC-Roots是否可达</li>
<li>枚举 GC Roots</li>
</ul>
<p>可达性分析，可以解决对象循环引用的问题</p>
<p>如图3.1.1所示的对象中，ObjD、ObjE、ObjF均为GC不可达，可以被GC回收掉</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-473f69299d0029a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.1.1 GC Roots reachable analyze"></p>
<p>图3.1.1 GC Roots reachable analyze</p>
<h4 id="3-1-4-引用方式"><a href="#3-1-4-引用方式" class="headerlink" title="3.1.4 引用方式"></a>3.1.4 引用方式</h4><p>引用方式的回收时机强调的是该引用方式为对象仅存的形式。</p>
<ul>
<li>（<strong>强</strong>）<strong>StrongReference</strong>—protects the referred object from collection by GC</li>
<li>（<strong>软</strong>）<strong>SoftReference</strong>—won’t be collected until its memory is needed</li>
<li>（<strong>弱</strong>）<strong>WeakReference</strong>—garbage collects when no Strong or Soft refs</li>
<li>（<strong>虚</strong>）<strong>PhantomReference</strong>—after finalized, before reclaimed</li>
</ul>
<p>强引用即为一般引用，软引用会在内存不足时回收，弱引用则是在GC时立即回收，虚引用一般用于标记GC对对象内存的操作。</p>
<h4 id="3-1-5-内存回收方式"><a href="#3-1-5-内存回收方式" class="headerlink" title="3.1.5 内存回收方式"></a>3.1.5 内存回收方式</h4><ul>
<li>GC、收集算法、收集器种类 枚举根节点</li>
<li>SafePoint &amp; SafeRegion（只有到达SafePoint，非运行状态的用户线程处于SafeRegion时才可以STW）</li>
<li>分代回收?</li>
</ul>
<p>GC运行时，需要Stop The World，HotSpot中，利用OopMap存储对象引用</p>
<p>图3.1.5.1展示了HotSpot的堆结构，可以看到整个堆内存分为三代（年轻代、老年代、永久代”JAVA 8已放弃永久代”）</p>
<p>其中年轻代又分为三个区域（一个Eden，两个Survivor，如此划分是为GC收集算法所做的准备，后面的篇幅有具体介绍）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-0cc80185075e1e36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.1.5.1 HotSpot Heap Structure"></p>
<p>图3.1.5.1 HotSpot Heap Structure</p>
<p>图3.1.5.2 为本文2.1中示例代码的样式堆占用情况（具体数据依机器而变，参考价值有限）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-5def65145209ff4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.1.5.2 Heap Usage ratio"></p>
<p>图3.1.5.2 Heap Usage ratio</p>
<h4 id="3-1-6-Java-的-GC-Roots"><a href="#3-1-6-Java-的-GC-Roots" class="headerlink" title="3.1.6 Java 的 GC Roots"></a>3.1.6 Java 的 GC Roots</h4><p>可以作为GC Roots的有：</p>
<ul>
<li>JVM Stack(Stack Frame 的本地变量表)中引用的对象</li>
<li>Native Method Stack 中</li>
<li>JNI(Native 方法)引用 的对象</li>
<li>Method Area 中类静态属性引用的对象</li>
<li>Method Area 中常量引用的对象</li>
</ul>
<h4 id="3-1-7-SafePoint-amp-SafeRegion"><a href="#3-1-7-SafePoint-amp-SafeRegion" class="headerlink" title="3.1.7 SafePoint &amp; SafeRegion"></a>3.1.7 SafePoint &amp; SafeRegion</h4><ul>
<li>只有SafePoint才能STW(方法调用、循环跳 转、异常跳转)(抢先中断、主动中断)</li>
<li>SafeRegion 无CPU时间程序——扩展的 SafePoint、离开时检查是否在进行GC</li>
<li>-XX:SurvivorRatio</li>
<li>可以把SafeRegion看成是扩大了的SafePoint</li>
</ul>
<h3 id="3-2-内存空间划分"><a href="#3-2-内存空间划分" class="headerlink" title="3.2 内存空间划分"></a>3.2 内存空间划分</h3><p>在上一节中，我们可以了解到，虚拟机可以分为如下五个部分：</p>
<ul>
<li>方法区</li>
<li>堆</li>
<li>虚拟机栈</li>
<li>程序计数器 </li>
<li>本地方法栈</li>
</ul>
<p>其中，方法区与堆是进程之间共享的，剩余的三个区块，都是线程级别做出的划分。方法区的回收管理相比于GC原理更为复杂，我们不作介绍。</p>
<p>针对每个线程，后三个区块的协作机理是：<br>程序计数器记录当前栈帧，在线程运行本地方法时计数器不做记录。</p>
<h3 id="3-3-垃圾回收"><a href="#3-3-垃圾回收" class="headerlink" title="3.3 垃圾回收"></a>3.3 垃圾回收</h3><h4 id="3-3-1-分代回收"><a href="#3-3-1-分代回收" class="headerlink" title="3.3.1 分代回收"></a>3.3.1 分代回收</h4><p>配置参数：</p>
<ul>
<li>-XX:NewRatio(Client/ Server差异化配置)</li>
<li>-XX:PermSize</li>
<li>…</li>
</ul>
<p>分代回收主要是为了提升效率，减少不不要的GC（对于需要长时间保留在内存中的对象进行频次更低的GC扫描）</p>
<h4 id="3-3-2-部分JVM配置参数"><a href="#3-3-2-部分JVM配置参数" class="headerlink" title="3.3.2 部分JVM配置参数"></a>3.3.2 部分JVM配置参数</h4><p>图3.3.2.1为部分JVM常规参数一览表，JVM的可配置参数极其丰富，有兴趣读者可查阅其它资料</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-c09be6dd982fbba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.2.1 部分JVM常规参数一览表"></p>
<p>图3.3.2.1 部分JVM常规参数一览表</p>
<h4 id="3-3-3-内存分配与回收策略"><a href="#3-3-3-内存分配与回收策略" class="headerlink" title="3.3.3 内存分配与回收策略"></a>3.3.3 内存分配与回收策略</h4><ul>
<li>Eden为主，TLAB为辅</li>
<li>直接进入Old-generation的情况、OOM</li>
<li>MinorGC &amp; FullGC/MajorGC（图3.3.3.3 MinorGC &amp; MajorGC）</li>
</ul>
<p>在年轻代内存够用的情况下，内存会被直接分配到年轻代中的Eden区域。（图3.3.3.1 写入年轻代Eden区）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-242a868f2c4d6c45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.3.1 写入年轻代Eden区"></p>
<p>图3.3.3.1 写入年轻代Eden区</p>
<p>在多次GC后，仍然存活的内存会在满足虚拟机配置参数的条件下被晋升到老年区。（图3.3.3.1 展示了年代之间的晋升）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-2540999a7248fa74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.3.2 晋升概览图"></p>
<p>图3.3.3.2 晋升概览图</p>
<p>针对不同年代，虚拟机会采用不同的收集器分时机进行收集，总结来看，年轻代的GC会比老年代的GC <strong>更频繁，效率也更高</strong>。（图3.3.3.3 展示了MinorGC 与 MajorGC的回收成效示例）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-facf61f82cf12b67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.3.3 MinorGC &amp; MajorGC"></p>
<p>图3.3.3.3 MinorGC &amp; MajorGC</p>
<h4 id="3-3-4-内存分配"><a href="#3-3-4-内存分配" class="headerlink" title="3.3.4 内存分配"></a>3.3.4 内存分配</h4><ul>
<li>优先分配Eden（图3.3.4.1 展示直接分配至Eden区的情况）</li>
<li>大对象直接进入old-generation</li>
<li>长期存活对象进入old-generation(年龄判定)</li>
<li>空间分配担保（风险、担保失败、OOM）</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-09da3e69c1e7de12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.4.1 对象空间分配"></p>
<p>图3.3.4.1 对象空间分配</p>
<p>图3.3.4.2-图3.3.4.4展示了对象年龄的计算方法</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-099ba10858c1daac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.4.2 对象年龄"></p>
<p>图3.3.4.2 对象年龄</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-f1b583b94f371c44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.4.3 对象年龄的增长示例"></p>
<p>图3.3.4.3 对象年龄的增长示例</p>
<p>除了满足晋升年龄限制条件的对象外，当年轻代的Survivor中对象平均年龄超过一定限度时，有可能会被整体直接晋升到老年区，而不用等到累加到限定的年龄。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-65c85ce0940865cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.4.4 从年轻代晋升到老年代"></p>
<p>图3.3.4.4 从年轻代晋升到老年代</p>
<p>在Minor GC进行之前，如果年轻代的内存之和超过了老年代可用内存大小，会涉及到一个担保的概念，如果不允许老年代担保，会直接抛出OOM异常。<br>图3.3.4.5 描述了整个内存分配的概览</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-a9b46c9c1ef158eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.4.5 直接分配至Eden区"></p>
<p>图3.3.4.5 直接分配至Eden区</p>
<h4 id="3-3-5-垃圾收集算法"><a href="#3-3-5-垃圾收集算法" class="headerlink" title="3.3.5 垃圾收集算法"></a>3.3.5 垃圾收集算法</h4><ul>
<li>标记-清除</li>
<li>复制</li>
<li>标记-整理</li>
</ul>
<p>标记清除是最简单的办法，但是它有一个弊端：会产生内存碎片（当可用内存不够时，会提前触发FullGC）。</p>
<p>复制算法能够解决这一问题，但是会造成空间的浪费，之所以HotSpot年轻代GC能够采用复制算法，是因为临时变量都比较”短命”（MinorGC回收效率基本都能达到80%以上），这样一来就可以考虑使用复制算法，”浪费”掉的内存处于可接受范围内。（Eden:Survivor1:Survivor2 常见比例会维持在 8:1:1左右）</p>
<h5 id="3-3-5-1-标记整理"><a href="#3-3-5-1-标记整理" class="headerlink" title="3.3.5.1 标记整理"></a>3.3.5.1 标记整理</h5><p>需要先标记，而后对标记可清楚的内存进行清理：</p>
<p>图3.3.5.1.1 为标记过程，图3.3.5.1.2 为直接清除后的内存情况，可以看到未被回收的内存之间会有大小不等的间隔，这就是”内存碎片”。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-dffef12d27e0440c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.5.1.1 Marking"></p>
<p>图3.3.5.1.1 Marking</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-7d913bf3a474dcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.5.1.2 Normal Deletion"></p>
<p>图3.3.5.1.2 Normal Deletion</p>
<h5 id="3-3-5-2-复制算法"><a href="#3-3-5-2-复制算法" class="headerlink" title="3.3.5.2 复制算法"></a>3.3.5.2 复制算法</h5><p>年轻代一般会采用的算法，简单高效。</p>
<p>图3.3.5.2 为HotSpot年轻代复制算法示意图，GC时，会把无法回收的内存对象”复制”至Survivor中的一块区域——Survivor 0/1会在两次相邻MinorGC之间来回切换 Copy的 From/To角色</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-50f18bb588311844.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.5.2 Coping Referenced Object"></p>
<p>图3.3.5.2 Coping Referenced Object</p>
<h5 id="3-3-5-3-标记整理算法"><a href="#3-3-5-3-标记整理算法" class="headerlink" title="3.3.5.3 标记整理算法"></a>3.3.5.3 标记整理算法</h5><p>标记整理与标记清理的不同点在于，多了一步整理的操作，而不是直接的清除可清除内存（图3.3.5.3 展示了操作过程，可以看到内存碎片不存在了）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-e57595176a60153f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.5.3 删除整理"></p>
<p>图3.3.5.3 删除整理</p>
<h4 id="3-3-6-垃圾收集器种类"><a href="#3-3-6-垃圾收集器种类" class="headerlink" title="3.3.6 垃圾收集器种类"></a>3.3.6 垃圾收集器种类</h4><p>垃圾收集器从运行方式上来分，主要分串行、并行两类。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-d44647bb58bf7c2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.6.0.1 串行-并行收集器"></p>
<p>图3.3.6.0.1 串行-并行收集器</p>
<p>由图3.3.6.1可见两种方式的主要区别是在STW时运行GC的线程数量不一样，然而并不能简单得理解”pause 时间越短”越好，在低性能的Client上需要考虑多线程切换的消耗。</p>
<blockquote>
<p>Stop the world 会暂停所有用户线程</p>
</blockquote>
<p>具体细化，HotSpot中的收集器有如下几种（JDK1.7U14）：</p>
<ul>
<li>Serial(串行)</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
<li>Serial Old(串行)</li>
<li>Parallel Old</li>
<li>CMS</li>
<li>G1—Garbage First(JDK 7U14)</li>
</ul>
<p>可以依照各收集器的试用内存年代做划分：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-a5848042f2a13510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.6.0.2 GC收集器"></p>
<p>图3.3.6.0.2 GC收集器</p>
<p><strong>下面就各收集器特点做要点说明：</strong></p>
<h5 id="3-3-6-1-Serial"><a href="#3-3-6-1-Serial" class="headerlink" title="3.3.6.1 Serial"></a>3.3.6.1 Serial</h5><ul>
<li>简单高效——没有线程交互的开销</li>
<li>常用于Client</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-26a178b15d61c0d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.6.1 Serial运行示意图"></p>
<p>图3.3.6.1 Ser<br>ial运行示意图</p>
<h5 id="3-3-6-2-ParNew"><a href="#3-3-6-2-ParNew" class="headerlink" title="3.3.6.2 ParNew"></a>3.3.6.2 ParNew</h5><ul>
<li>常用于Server模式</li>
<li>只能与CMS配合工作</li>
<li>单CPU效果不如Serial</li>
<li>-XX:ParallelGCThreads限制线程数量</li>
<li>关注吞吐量</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-0ba80f3d07039584.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.6.2 ParNew运行示意图"></p>
<p>图3.3.6.2 P<br>arNew运行示意图</p>
<h5 id="3-3-6-3-Parallel-Scavenge"><a href="#3-3-6-3-Parallel-Scavenge" class="headerlink" title="3.3.6.3 Parallel Scavenge"></a>3.3.6.3 Parallel Scavenge</h5><ul>
<li>-XX:MaxGCPauseMillis——停顿时间以牺牲吞吐量和新生代空间为代价</li>
<li>-XX:GCTimeRatio</li>
<li>自适应调节策略——无需手动设置-Xmn、SurvivorRatio、晋升 OldGeneration大小等参数</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-8c509f9d210e2339.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.6.3 Parallel Scavenge运行示意图"></p>
<p>图3.3.6.3 Parallel Scavenge运行示意图</p>
<h5 id="3-3-6-4-Serial-Old"><a href="#3-3-6-4-Serial-Old" class="headerlink" title="3.3.6.4 Serial Old"></a>3.3.6.4 Serial Old</h5><ul>
<li>主要用于Client</li>
<li>可作为CMS的后备选项</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-8927a9cb7340b35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.6.4 Serial Old运行示意图"></p>
<p>图3.3.6.4 Serial O<br>ld运行示意图</p>
<h5 id="3-3-6-5-Parallel-Old"><a href="#3-3-6-5-Parallel-Old" class="headerlink" title="3.3.6.5 Parallel Old"></a>3.3.6.5 Parallel Old</h5><ul>
<li>Parallel Scavenge的Old generation版本</li>
<li>多线程 标记-整理</li>
<li>配合ps使用在注重吞吐量及CPU敏感场合</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-3d1db4efd09b12db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.6.5 Parallel Old运行示意图"></p>
<p>图3.3.6.5 Parallel Old运行示意图</p>
<h5 id="3-3-6-6-CMS"><a href="#3-3-6-6-CMS" class="headerlink" title="3.3.6.6 CMS"></a>3.3.6.6 CMS</h5><ul>
<li>目标:获取最短回收停顿时间(标记-清除算法)</li>
<li>步骤:初始标记-并发标记-重新标记-并发清除</li>
<li>缺点:CPU资源敏感、无法处理浮动垃圾(OG68%启用 CMS，失败时启用Serial Old)、产生大量碎片</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-962ab459822c3a93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p>
<p>图3.3.6.6.1 CMS运行示意图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-0d5f648b819bd823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.6.6.2 Serial收集器与CMS收集器操作线程比较"></p>
<p>图3.3.6.6.2 Serial收集器与CMS收集器操作线程比较</p>
<h5 id="3-3-6-7-G1"><a href="#3-3-6-7-G1" class="headerlink" title="3.3.6.7 G1"></a>3.3.6.7 G1</h5><p>G1 相比于前面所述的收集器格外不一样，因为G1在内存的划分上，将内存平分为大小相等的几个区域，年轻代与老年代之间不在是物理隔离，总结起来，G1特点有：</p>
<ul>
<li>并行与并发</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测停顿</li>
<li>将堆划分为多个大小相等的Region</li>
<li>Y/O不再物理隔离</li>
<li>有计划避免全盘GC</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-d3f472e8f57f4507.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="图3.3.6.7.1 G1 运行示意图"></p>
<p>图3.3.6.7.1 G1 运行示意图</p>
<p>G1会维护一个Region回收优先级列表（根据Region回收价值排序），RememberedSet可保证不全堆扫描也不会遗漏，线程要保证暂停在安全点，就需要维护一个RememberSetLog，这些列表需要在最终标记时与RememberedSet合并，确保不会出错。</p>
<h4 id="3-3-7-性能指标"><a href="#3-3-7-性能指标" class="headerlink" title="3.3.7 性能指标"></a>3.3.7 性能指标</h4><ul>
<li>吞吐量(Throughput):在一段长时间内，没有花费在垃圾收集上的时间所 占的比例。</li>
<li>垃圾收集代价(Garbage Collection Overhead):垃圾收集时间所占的比例。</li>
<li>暂停时间(Pause Time): 当执行垃圾收集时，程序被迫暂停的时间长度。</li>
<li>垃圾收集频率(Frequency Of Collection):相对于程序的执行，垃圾收集执 行的频率。</li>
<li>覆盖区(Footprint): 大小度量，如堆的大小。</li>
<li>敏捷度(Promptness): 从一个对象成为垃圾时到内存被回收时之间的时间 长度。</li>
</ul>
<h4 id="3-3-8-收集器策略"><a href="#3-3-8-收集器策略" class="headerlink" title="3.3.8 收集器策略"></a>3.3.8 收集器策略</h4><ul>
<li>Server:<ul>
<li>低停顿：ParNew + CMS(Serial Old)</li>
<li>高吞吐/低CPU：Parallel Scavenge + Parallel Old</li>
</ul>
</li>
<li>Client:<ul>
<li>Serial + Serial Old</li>
</ul>
</li>
</ul>
<h2 id="四、JVM与Android虚拟机的异同"><a href="#四、JVM与Android虚拟机的异同" class="headerlink" title="四、JVM与Android虚拟机的异同"></a>四、JVM与Android虚拟机的异同</h2><h3 id="4-1-JVM"><a href="#4-1-JVM" class="headerlink" title="4.1 JVM"></a>4.1 JVM</h3><p>JAVA虚拟机运行的是JAVA字节码,JVM基于栈</p>
<ul>
<li>JAVA程序经过编译，生成JAVA字节码保存在class文件中，JVM通过解码class文件中的内容来运行程序。</li>
</ul>
<p>关于栈式虚拟机：</p>
<ul>
<li>代码必须使用这些指令来移动变量(即push和pop)</li>
<li>代码尺寸小和解码效率会更高些</li>
<li>堆栈虚拟机指令有隐含的操作数。</li>
</ul>
<h3 id="4-2-安卓虚拟机"><a href="#4-2-安卓虚拟机" class="headerlink" title="4.2 安卓虚拟机"></a>4.2 安卓虚拟机</h3><h4 id="4-2-1-DVM与JVM："><a href="#4-2-1-DVM与JVM：" class="headerlink" title="4.2.1 DVM与JVM："></a>4.2.1 DVM与JVM：</h4><ul>
<li>JVM基于栈，Dalvik基于寄存器。Dalvik运行dex文件，而JVM运行java字节码自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）</li>
<li>与一般标准Java虚拟机不同在于：<ul>
<li>占用更少空间</li>
<li>为简化翻译，常量池只使用32位索引</li>
<li>标准Java字节码实行8位堆栈指令,Dalvik使用16位指令集直接作用于局部变量。局部变量通常来自4位的“虚拟寄存器”区。这样减少了Dalvik的指令计数，提高了翻译速度。</li>
</ul>
</li>
<li>Dalvik虚拟机运行的是Dalvik字节码<ul>
<li>DVM运行的是Dalvik字节码，所有的Dalvik字节码由JAVA字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中，DVM通过解释DEX文件来执行这些字节码。</li>
</ul>
</li>
<li>Dalvik可执行文件体积更小</li>
</ul>
<h4 id="4-2-2-DVM与ART"><a href="#4-2-2-DVM与ART" class="headerlink" title="4.2.2 DVM与ART"></a>4.2.2 DVM与ART</h4><ul>
<li>区别：Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码</li>
<li>ART相比于DVM（空间换时间）：<ul>
<li>(优点)系统性能显著提升</li>
<li>(优点)应用启动更快、运行更快、体验更流畅、触感反馈更及时</li>
<li>(优点)续航能力提升</li>
<li>(优点)支持更低的硬件</li>
<li>(缺点)更大的存储空间占用，可能增加10%-20%</li>
<li>(缺点)更长的应用安装时间</li>
</ul>
</li>
</ul>
<h2 id="五、如何“防治”"><a href="#五、如何“防治”" class="headerlink" title="五、如何“防治”"></a>五、如何“防治”</h2><h3 id="5-1-攻"><a href="#5-1-攻" class="headerlink" title="5.1 攻"></a>5.1 攻</h3><p>Android内存泄露判定-解决方法</p>
<ul>
<li>工具<ul>
<li>IDE自带工具（图5.1.1为AS分析出的引用路径）</li>
<li>MAT/Android Studio Profiler/第三方(图5.1.2为MAT分析出的某例泄露)</li>
<li>LeakCanary 等监测工具(图5.1.3为LeakCanary监测出的未反注册及未取消动画更新监听的泄露GC-Root引用路径)</li>
</ul>
</li>
</ul>
<p><em>各大工具的使用方法因篇幅所限，就不具体介绍，相关资料亦是汗牛充犊。</em></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-ca53c4d2e0fd72d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="5.1.1"></p>
<p>图5.1.1 AS分析出的泄露现场</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-c29f25476bbacbe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="5.1.2"></p>
<p>图5.1.2 Leak by MAT</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-97d976558b387970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="5.1.3"></p>
<p>图5.1.3 by LeakCanary</p>
<ul>
<li>查找内存泄露步骤:<ul>
<li>了解OutOfMemoryError 情况</li>
<li>重现<ul>
<li>Heap Dump</li>
<li>计算这个对象到 GC roots 的最短强引用路径。</li>
<li>剔除无用引用<h3 id="5-2-防"><a href="#5-2-防" class="headerlink" title="5.2 防"></a>5.2 防</h3><h4 id="5-2-1-Java"><a href="#5-2-1-Java" class="headerlink" title="5.2.1 Java:"></a>5.2.1 Java:</h4></li>
</ul>
</li>
</ul>
</li>
<li>减少临时对象的使用</li>
<li>尽量使用StringBuffer,而不用String来累加字符串</li>
<li>尽量避免使用 static 成员变量</li>
<li>分散对象创建或删除的时间</li>
<li>勿override finalize()</li>
</ul>
<h4 id="5-2-2-Android"><a href="#5-2-2-Android" class="headerlink" title="5.2.2 Android:"></a>5.2.2 Android:</h4><ul>
<li>生命周期最小化(如用ApplicationContext替代Activity)</li>
<li>不要在静态变量或者静态内部类中使用非静态外部成员变量，实在要用——<ul>
<li>将内部类改为静态内部类</li>
<li>静态内部类中使用弱引用来引用外部类的成员变量</li>
</ul>
</li>
<li>Handler 尽量不持有对象、依赖场景结束时cancelMessageAndCallback</li>
<li>关闭资源(集合清除、Bitmap.recycle、Closable.close、Register.unregister、 Observer.remove、WebView处理)<br>  及时终止或取消异步任务</li>
<li>时刻记得不要加载过大的Bitmap对象；(BitmapFactory.Options)</li>
<li>优化界面交互过程中频繁的内存使用；</li>
<li>有些地方避免使用强引用，替换为弱引用等操作。</li>
<li>对批量加载等操作进行缓存设计，譬如列表图片显示，Adapter的convertView缓存等。</li>
<li>尽可能的复用资源；譬如系统本身有很多字符串、颜色、图片、动画、样式，尽量复用style以节约内存。</li>
<li>对于有缓存等存在的应用尽量实现onLowMemory()和onTrimMemory()方法。</li>
<li>尽量使用线程池替代多线程操作，这样可以节约内存及CPU占用率。</li>
<li>尽量管理好自己的Service、Thread等后台的生命周期，不要浪费内存占用。</li>
<li>尽量的优化自己的代码，减少冗余，进行编译打包等优化对齐处理，避免类加载时浪费内存。</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/内存泄漏" target="_blank" rel="noopener">内存泄漏Wiki词条</a></li>
<li><a href="https://www.amazon.cn/gp/product/B00D2ID4PK/ref=od_aui_detailpages00?ie=UTF8&amp;psc=1" target="_blank" rel="noopener">《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》周志明著</a></li>
<li><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener">Java Garbage Collection Basics</a></li>
<li><a href="http://bugs.java.com/view_bug.do?bug_id=6668279" target="_blank" rel="noopener">System.gc() should indicate that we don’t recommend use and don’t<br> guarantee behaviour</a></li>
<li><a href="https://stackoverflow.com/questions/2414105/why-is-it-bad-practice-to-call-system-gc" target="_blank" rel="noopener">Why is it bad practice to call System.gc()?</a></li>
<li><a href="http://www.jianshu.com/p/8edac8e09b3e" target="_blank" rel="noopener">JAVA虚拟机与Android虚拟机的区别</a></li>
<li><a href="http://blog.csdn.net/u010299178/article/details/52059998" target="_blank" rel="noopener">Android优化改动——java代码</a></li>
<li><a href="http://www.jb51.net/article/88708.htm" target="_blank" rel="noopener">Android DVM/ART 区分</a></li>
</ul>
</blockquote>
<blockquote>
<p>拍砖：<br><a href="mailto:chengong90@gmail.com" target="_blank" rel="noopener">chengong90@gmail.com</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存泄露/">内存泄露</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-技术/程序/Bitmap recycle做了什么"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/03/09/技术/程序/Bitmap recycle做了什么/">看看Bitmap源码中recycle 做了什么</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/03/09/技术/程序/Bitmap recycle做了什么/" class="article-date">
	  <time datetime="2018-03-08T16:35:35.000Z" itemprop="datePublished">2018-03-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/技术/">技术</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>看看Bitmap源码中recycle 做了什么</p>
<p>PS：源码查看工具网站：AndroidXref、grepCode</p>
</blockquote>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p> 在Bitmap调用recycle之后再去使用，会有invalid Bitmap的异常导致应用崩溃，实际项目中其实是碰到了tgkill的Native代码崩溃的堆栈信息：</p>
<p><img src="../../pic_resource/stacktrace_of_tgkill.png" alt=""></p>
<p>分析Bitmap getGenerationId在源码中的调用情况：（git clone Framework 源码之后用sublimeText搜索得如下结果，txt文件已过滤）</p>
<p><img src="../../pic_resource/FindResults.png" alt=""></p>
<p>绿色框中的代码因为是surface的API，或者是JavaDoc的注释，可以忽略不计，可以看到有效调用就是关于Notification的调用；</p>
<p>结合GP后台的崩溃占用情况（&gt;7.0占比较高，6.0亦有发生），查阅AndroidDeveloper的v6.0 changeLog，发现有这么一条：</p>
<p><img src="../../pic_resource/Android6.0_Changes_Notification.png" alt=""></p>
<p>看到其中关键信息 ==reuse Notification.Builder instance==，但鉴于其它App没有出现这种级别的问题，所以另谋其它出路；</p>
<p>剩下的就只剩Bitmap了</p>
<h2 id="Bitmap-recycle做了什么"><a href="#Bitmap-recycle做了什么" class="headerlink" title="Bitmap recycle做了什么"></a>Bitmap recycle做了什么</h2><h3 id="Bitmap-cpp"><a href="#Bitmap-cpp" class="headerlink" title="Bitmap.cpp"></a>Bitmap.cpp</h3><p>source code on xRef: <a href="http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp" target="_blank" rel="noopener">http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">782</span><span class="function"><span class="keyword">static</span> jboolean <span class="title">Bitmap_recycle</span><span class="params">(JNIEnv* env, jobject, jlong bitmapHandle)</span> </span>&#123;</span><br><span class="line"><span class="number">783</span>    <span class="function">LocalScopedBitmap <span class="title">bitmap</span><span class="params">(bitmapHandle)</span></span>;</span><br><span class="line"><span class="number">784</span>    bitmap-&gt;freePixels();</span><br><span class="line"><span class="number">785</span>    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line"><span class="number">786</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">168</span><span class="keyword">void</span> Bitmap::freePixels() &#123;</span><br><span class="line"><span class="number">169</span>    AutoMutex _lock(mLock);</span><br><span class="line"><span class="number">170</span>    <span class="keyword">if</span> (mPinnedRefCount == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">171</span>        doFreePixels();</span><br><span class="line"><span class="number">172</span>        mPixelStorageType = PixelStorageType::Invalid;</span><br><span class="line"><span class="number">173</span>    &#125;</span><br><span class="line"><span class="number">174</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">176</span><span class="keyword">void</span> Bitmap::doFreePixels() &#123;</span><br><span class="line"><span class="number">177</span>    <span class="keyword">switch</span> (mPixelStorageType) &#123;</span><br><span class="line"><span class="number">178</span>    <span class="keyword">case</span> PixelStorageType::Invalid:</span><br><span class="line"><span class="number">179</span>        <span class="comment">// already free'd, nothing to do</span></span><br><span class="line"><span class="number">180</span>        <span class="keyword">break</span>;</span><br><span class="line"><span class="number">181</span>    <span class="keyword">case</span> PixelStorageType::External:</span><br><span class="line"><span class="number">182</span>        mPixelStorage.external.freeFunc(mPixelStorage.external.address,</span><br><span class="line"><span class="number">183</span>                mPixelStorage.external.context);</span><br><span class="line"><span class="number">184</span>        <span class="keyword">break</span>;</span><br><span class="line"><span class="number">185</span>    <span class="keyword">case</span> PixelStorageType::Ashmem:</span><br><span class="line"><span class="number">186</span>        munmap(mPixelStorage.ashmem.address, mPixelStorage.ashmem.size);</span><br><span class="line"><span class="number">187</span>        close(mPixelStorage.ashmem.fd);</span><br><span class="line"><span class="number">188</span>        <span class="keyword">break</span>;</span><br><span class="line"><span class="number">189</span>    <span class="keyword">case</span> PixelStorageType::Java:</span><br><span class="line"><span class="number">190</span>        JNIEnv* env = jniEnv();</span><br><span class="line"><span class="number">191</span>        LOG_ALWAYS_FATAL_IF(mPixelStorage.java.jstrongRef,</span><br><span class="line"><span class="number">192</span>                <span class="string">"Deleting a bitmap wrapper while there are outstanding strong "</span></span><br><span class="line"><span class="number">193</span>                <span class="string">"references! mPinnedRefCount = %d"</span>, mPinnedRefCount);</span><br><span class="line"><span class="number">194</span>        env-&gt;DeleteWeakGlobalRef(mPixelStorage.java.jweakRef);</span><br><span class="line"><span class="number">195</span>        <span class="keyword">break</span>;</span><br><span class="line"><span class="number">196</span>    &#125;</span><br><span class="line"><span class="number">197</span></span><br><span class="line"><span class="number">198</span>    <span class="keyword">if</span> (android::uirenderer::Caches::hasInstance()) &#123;</span><br><span class="line"><span class="number">199</span>        android::uirenderer::Caches::getInstance().textureCache.releaseTexture(</span><br><span class="line"><span class="number">200</span>                mPixelRef-&gt;getStableID());</span><br><span class="line"><span class="number">201</span>    &#125;</span><br><span class="line"><span class="number">202</span>&#125;</span><br></pre></td></tr></table></figure>
<p>注意析构函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">164</span> Bitmap::~Bitmap() &#123;</span><br><span class="line"><span class="number">165</span>    doFreePixels();</span><br><span class="line"><span class="number">166</span> &#125;</span><br></pre></td></tr></table></figure>
<p>还需注意到代码：</p>
<p><img src="../../pic_resource/bitmap_cpp_assert_valid.png" alt=""></p>
<p>结合Bitmap.cpp的其它代码，只有在Bitmap recycle之后又拿来使用才会出现这个assertValid断言错误，遂将矛头指向Bitmap recycle</p>
<h3 id="不调用recycle-会怎样？"><a href="#不调用recycle-会怎样？" class="headerlink" title="不调用recycle()会怎样？"></a>不调用recycle()会怎样？</h3><p>Android2.3（API 11）之前，Bitmap开辟的内存位于native Stack，需要手动调用recycle进行释放，而2.3之后属于VM的heap，系统GC会自动处理。</p>
<p>而我们在2.3之后的系统中调用Bitmap的recycle，唯一的作用，就是把Bitmap释放的动作提前了，私以为，仅有的效用是会降低OOM发生的概率</p>
<p>这一点也可以从Bitmap AndroidAPI解释网页上看出一点端倪</p>
<p><img src="../../pic_resource/Java_Bitmap_recycle.png" alt=""></p>
<blockquote>
<p>this is an advanced call, and normally need not be called…</p>
</blockquote>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>在所有会调用Bitmap.recycle()的地方，对相应的recycle状态检查，如果发现有recycle之后仍然在使用的地方，则直接抛出异常，暴露问题，就像这样：</p>
<p><img src="../../pic_resource/BitmapWatcher.png" alt=""></p>
<p>这样，在Monkey测试覆盖面够广时，就可以预期暴露出问题所在了；</p>
<p>关于Bitmap的检查，还有一种思路是使用hook方式进行，这样还可以对第三方依赖lib进行检查，后期如果应用这种方式，我再补充一篇</p>
<hr>
<p>Ref:</p>
<ol>
<li>bitmap recycle不当调用引发的问题 <a href="http://www.jianshu.com/p/b5c8e98ff5b0" target="_blank" rel="noopener">http://www.jianshu.com/p/b5c8e98ff5b0</a></li>
<li>Bitmap source Code：<a href="https://android.googlesource.com/platform/frameworks/base/+/47fb191/core/jni/android/graphics/Bitmap.cpp；（GrepCode网站上5.0r1的Bitmap" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/47fb191/core/jni/android/graphics/Bitmap.cpp；（GrepCode网站上5.0r1的Bitmap</a> sourcecode）<a href="http://grepcode.com/file/repo1.maven.org/maven2/org.robolectric/android-all/5.0.0_r2-robolectric-0/android/graphics/Bitmap.java；（AndroidXref网站上的Bitmap" target="_blank" rel="noopener">http://grepcode.com/file/repo1.maven.org/maven2/org.robolectric/android-all/5.0.0_r2-robolectric-0/android/graphics/Bitmap.java；（AndroidXref网站上的Bitmap</a> 7.1.1 sourcecode）<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#896" target="_blank" rel="noopener">http://androidxref.com/7.1.1_r6/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#896</a></li>
<li>Bitmap API 解释on AndroidDeveloper：<a href="https://stuff.mit.edu/afs/sipb/project/android/docs/reference/android/graphics/Bitmap.html#recycle()" target="_blank" rel="noopener">https://stuff.mit.edu/afs/sipb/project/android/docs/reference/android/graphics/Bitmap.html#recycle()</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recycle/">recycle</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-技术/程序/Android--Monkey测试"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/03/09/技术/程序/Android--Monkey测试/">Android Monkey 测试时防止通知栏下拉</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/03/09/技术/程序/Android--Monkey测试/" class="article-date">
	  <time datetime="2018-03-08T16:35:35.000Z" itemprop="datePublished">2018-03-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/技术/">技术</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p>Android monkey test — <a href="http://einverne.github.io/post/2016/09/android-monkey-test.html#防止通知栏下拉" target="_blank" rel="noopener">http://einverne.github.io/post/2016/09/android-monkey-test.html#防止通知栏下拉</a></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Monkey/">Monkey</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SystemBar/">SystemBar</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-技术/Android/冻结帧"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/03/09/技术/Android/冻结帧/">冻结帧</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/03/09/技术/Android/冻结帧/" class="article-date">
	  <time datetime="2018-03-08T16:35:35.000Z" itemprop="datePublished">2018-03-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/技术/">技术</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><h4 id="基本知识准备"><a href="#基本知识准备" class="headerlink" title="基本知识准备"></a>基本知识准备</h4><ul>
<li>认识冻结帧FrozenFrame（FF）</li>
<li>Google Play Console（GPC）针对FF的各项指标含义</li>
<li>FF所属大类——SlowRendering</li>
<li>testing UI performance</li>
</ul>
<h4 id="GPC-FF告警解决办法"><a href="#GPC-FF告警解决办法" class="headerlink" title="GPC FF告警解决办法"></a>GPC FF告警解决办法</h4><p>手动测试、自动测试、解决关键问题——后续输出指南/标准</p>
<ul>
<li>手动测试重要场景，找到问题场景，解决痛点</li>
<li>自动化测试——搭建自动化测试、完善UI测试标准、足够好用的情况下考虑加入到后续新入UI的考量手段中</li>
<li>主动防御——对UI的实现标准化操作进行总结、输出至业务开发人员，提高UI质量</li>
</ul>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><h4 id="认识冻结帧FrozenFrame（FF）"><a href="#认识冻结帧FrozenFrame（FF）" class="headerlink" title="认识冻结帧FrozenFrame（FF）"></a>认识冻结帧FrozenFrame（FF）</h4><ul>
<li>定义</li>
<li>why 60 fps</li>
<li>16.67ms</li>
</ul>
<h4 id="Google-Play-Console（GPC）针对FF的各项指标含义"><a href="#Google-Play-Console（GPC）针对FF的各项指标含义" class="headerlink" title="Google Play Console（GPC）针对FF的各项指标含义"></a>Google Play Console（GPC）针对FF的各项指标含义</h4><blockquote>
<h4 id="Data-collection-details"><a href="#Data-collection-details" class="headerlink" title="Data collection details"></a>Data collection details</h4><p>Google collects the render time of each frame rendered by your app when using the UI Toolkit framework, <strong>not when using OpenGL directly.</strong></p>
</blockquote>
<p>控制面板</p>
<ul>
<li>Impacted sessions——每日会话中，绘制时间&gt;700ms的帧总数超过所有会话帧0.1%的用户占比</li>
<li>Number of sessions——被记录的帧数量</li>
<li>90th/99th percentile(ms)——90%/99%的用户的所有帧绘制时间都低于这一值</li>
</ul>
<p>图表指标（比率均是针对所有绘制超过16.67ms的帧）</p>
<ul>
<li>Missed Vsync——<a href="https://stackoverflow.com/questions/27947848/understanding-necessity-of-android-vsync-signals" target="_blank" rel="noopener">丢失系统Vsync</a>信号的占比（理解<a href="https://www.youtube.com/watch?v=1iaHxmfZGGc&amp;list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&amp;index=23" target="_blank" rel="noopener">VSYNC</a>）</li>
<li>High input latency——这些超过16.67ms的帧中输入法用时超过24ms的帧占比</li>
<li>Slow UI thread——UI thread用时超过8ms</li>
<li>Slow draw commands——给GPU发送绘制指令用时超过12ms</li>
<li>Slow bitmap uploads——bitmap上传至GPU用时超过3.2ms</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>ORG Google play console data</p>
<h4 id="FF所属大类——SlowRendering"><a href="#FF所属大类——SlowRendering" class="headerlink" title="FF所属大类——SlowRendering"></a>FF所属大类——<a href="https://developer.android.com/topic/performance/vitals/render.html" target="_blank" rel="noopener">SlowRendering</a></h4><ul>
<li>identifying jank<ul>
<li><a href="https://developer.android.com/topic/performance/vitals/render.html#visual-inspection" target="_blank" rel="noopener">Visual inspection</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/render.html#systrace" target="_blank" rel="noopener">Systrace</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/render.html#custom-monitoring" target="_blank" rel="noopener">Custom performance monitoring</a></li>
</ul>
</li>
<li>fixing jank<ul>
<li>查看常规的反面示例</li>
<li>如何避免——耗时操作应在非UI线程完成</li>
<li>UI复杂时<ul>
<li><a href="https://developer.android.com/training/testing/espresso/index.html" target="_blank" rel="noopener">写UI自动化测试代码</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/android-perf-testing/index.html#0" target="_blank" rel="noopener">自动化性能测试UI篇</a></li>
</ul>
</li>
</ul>
</li>
<li>Common sources of janks<ul>
<li>Scrollable lists<ul>
<li>RecycleView:notifyDataSetChanged</li>
<li>RecycleView:Nested RecyclerViews</li>
<li>RecyclerView: Too much inflation / Create taking too long</li>
<li>RecyclerView: Bind taking too long</li>
<li>RecyclerView or ListView: layout / draw taking too long</li>
<li>ListView: Inflation</li>
</ul>
</li>
<li>Layout performance<ul>
<li>Layout performance: Cost</li>
<li>Layout performance: Frequency</li>
</ul>
</li>
<li>Rendering performance<ul>
<li>Rendering performance: UI Thread<ul>
<li>If <strong>Record View#draw</strong> is taking a long time, it’s often the case that a bitmap is being painted on the UI thread. Painting to a bitmap uses CPU rendering, so should generally should be avoided. 使用<a href="https://developer.android.com/studio/profile/cpu-profiler.html#method_traces" target="_blank" rel="noopener">Android CPU Profiler</a> 确诊问题</li>
</ul>
</li>
<li>Rendering performance: RenderThread<ul>
<li>Canvas.saveLayer()</li>
<li>Animating large Paths</li>
<li>Canvas.clipPath</li>
</ul>
</li>
</ul>
</li>
<li>Thread scheduling delays</li>
<li>Object allocation and garbage collection</li>
</ul>
</li>
</ul>
<h4 id="testing-UI-performance"><a href="#testing-UI-performance" class="headerlink" title="testing UI performance"></a>testing UI performance</h4><ul>
<li>measuring UI performance</li>
<li>automating UI performance Tests</li>
</ul>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>可能诱因</p>
<h3 id="How——定位问题"><a href="#How——定位问题" class="headerlink" title="How——定位问题"></a>How——定位问题</h3><h4 id="Visual-inspection"><a href="#Visual-inspection" class="headerlink" title="Visual inspection"></a><a href="https://developer.android.com/topic/performance/vitals/render.html#visual-inspection" target="_blank" rel="noopener">Visual inspection</a></h4><ul>
<li>Run a <strong>==release==</strong> (or at least non-debuggable) version of your app. <strong>The ART runtime disables several important optimizations in order to support debugging features</strong>, so make sure you’re looking at something similar to what a user will see.</li>
<li><a href="https://developer.android.com/studio/profile/dev-options-rendering.html#ProfileGPURendering" target="_blank" rel="noopener">Enable Profile GPU Rendering</a>. <strong>Profile GPU Rendering</strong> displays bars on the screen that give you a quick visual representation of how much time it takes to render the frames of a UI window relative to the 16-ms-per-frame benchmark. Each bar has colored components that map to a stage in the rendering pipeline, so you can see which portion is taking the longest. For example, if the frame spends a lot of time handling input, you should look at your app code that handles user input.</li>
<li>There are certain components, such as <code>RecyclerView</code>, that are a <a href="https://developer.android.com/topic/performance/vitals/render.html#common-jank" target="_blank" rel="noopener">common source of jank</a>. If your app uses those components, it’s a good idea to run through those parts of the app.</li>
<li>Sometimes, jank can be reproduced only when the app is launched from a <a href="https://developer.android.com/topic/performance/launch-time.html#cold" target="_blank" rel="noopener">cold start</a>.</li>
<li>Try running your app on a slower device to exacerbate the problem.</li>
</ul>
<h4 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a><a href="https://developer.android.com/topic/performance/vitals/render.html#systrace" target="_blank" rel="noopener">Systrace</a></h4><ul>
<li>Systrace shows when each frame is drawn and color codes each frame to highlight slow render times. This helps you find individual janky frames more accurately than visual inspection. For more information, see <a href="https://developer.android.com/studio/profile/systrace.html#frames" target="_blank" rel="noopener">Inspecting Frames</a>.</li>
<li>Systrace detects problems in your app and displays <strong>alerts</strong> both in individual frames and the <a href="https://developer.android.com/studio/profile/systrace.html#alerts" target="_blank" rel="noopener">alerts</a> panel. Following directions in the alert is your best option.</li>
<li>Parts of the Android framework and libraries, such as <code>RecyclerView</code>, contain trace markers. So, the <strong>systrace timeline </strong>shows when those methods are executed on the UI thread and how long they take to execute.</li>
</ul>
<p>If systrace doesn’t show you details about why UI thread work is taking for a long time, then you’ll need to use <a href="https://developer.android.com/studio/profile/cpu-profiler.html#method_traces" target="_blank" rel="noopener">Android CPU Profiler</a> to record either a sampled or instrumented method trace. </p>
<h4 id="Custom-performance-monitoring"><a href="#Custom-performance-monitoring" class="headerlink" title="Custom performance monitoring"></a><a href="https://developer.android.com/topic/performance/vitals/render.html#custom-monitoring" target="_blank" rel="noopener">Custom performance monitoring</a></h4><p>If you can’t reproduce jank on a local device, you can build custom performance monitoring into your app to help identify the source of jank on devices in the field.</p>
<p>To do this, collect frame render times from specific parts of your app with <a href="https://developer.android.com/reference/android/support/v4/app/FrameMetricsAggregator.html" target="_blank" rel="noopener"><code>FrameMetricsAggregator</code></a> and record and analyze the data using <a href="https://firebase.google.com/docs/perf-mon/" target="_blank" rel="noopener">Firebase Performance Monitoring</a>.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul>
<li>To fix jank, inspect which frames aren’t completing in 16.7ms, and look for what is going wrong. Is <strong>Record View#draw</strong> taking abnormally long in some frames, or perhaps <strong>Layout</strong>? See the <a href="https://developer.android.com/topic/performance/vitals/render.html#common-jank" target="_blank" rel="noopener">Common sources of jank</a> below for these problems, and others.</li>
<li>To avoid jank, long running tasks should be run asynchronously outside of the UI thread. Always be aware of what thread you’re code is running on and use caution when posting non-trivial tasks to the main thread.</li>
<li>If you have a complex and important primary UI for your app (maybe the central scrolling list), consider <a href="https://developer.android.com/training/testing/performance.html#automate" target="_blank" rel="noopener">writing instrumentation tests</a> that can automatically detect slow render times and run the tests frequently to prevent regressions. For more information, see the <a href="https://codelabs.developers.google.com/codelabs/android-perf-testing/index.html" target="_blank" rel="noopener">Automated Performance Testing Codelab</a>.</li>
</ul>
<h3 id="Automated-Test-codelab"><a href="#Automated-Test-codelab" class="headerlink" title="Automated Test codelab"></a>Automated Test codelab</h3><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><ul>
<li>How to quickly navigate some Android Performance tools</li>
<li>How the Espresso testing framework can be used to write unit and performance tests</li>
<li>How to use MonkeyRunner and Gradle to automate the testing workflow</li>
<li>How to review systrace output to understand your app’s performance issues</li>
</ul>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li><p><a href="https://developer.android.com/studio/profile/systrace-commandline.html" target="_blank" rel="noopener">Systrace</a>、对其说明<a href="http://blog.udinic.com/2015/09/15/speed-up-your-app" target="_blank" rel="noopener">Link</a></p>
</li>
<li><p>在traceView中，选中帧后，按M键，可高亮帧</p>
<ul>
<li><a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="noopener">Profiling with Traceview and dmtracedump</a></li>
<li><a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="noopener">代码级traceview</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start tracing to "/sdcard/calc.trace"</span></span><br><span class="line">Debug.startMethodTracing(<span class="string">"calc"</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// stop tracing</span></span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure>
</li>
<li><p>frame dump</p>
<p><img src="../../pic_resource/frame_dump_example.jpg" alt=""></p>
</li>
<li><p><a href="https://developer.android.com/studio/profile/cpu-profiler.html#method_traces" target="_blank" rel="noopener">method trace</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/冻结帧/">冻结帧</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-技术/Android/【Android架构】Android架构初探"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/03/09/技术/Android/【Android架构】Android架构初探/">Android架构初探</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/03/09/技术/Android/【Android架构】Android架构初探/" class="article-date">
	  <time datetime="2018-03-08T16:35:35.000Z" itemprop="datePublished">2018-03-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/技术/">技术</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Android 从软件层面来看可以分为以下几个层级：</p>
<ul>
<li>Linux Kernel</li>
<li>HAL</li>
<li>Native C/C++ Libraries <strong>+</strong> AR</li>
<li>Java API Framework</li>
<li>System App</li>
</ul>
</blockquote>
<p><em>图示如下：</em><br><img src="http://upload-images.jianshu.io/upload_images/1481332-af50032816470c0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="android-stack_2x.png"><br><a href="https://developer.android.google.cn/guide/platform/index.html" target="_blank" rel="noopener">official site</a></p>
<hr>
<ol>
<li>Linux Kernel 内核层，系统运行基石，还包含一些基本的硬件驱动<pre><code>a. 安全性(Security)
b. 内存管理(Memory Management)
c. 进程管理(Process Management)
d. 网络堆栈(Network Stack)
e. 驱动程序模型(Driver Model)
</code></pre></li>
<li>硬件抽象层<pre><code>提供高级界面，为Java API Framework层显示硬件功能
</code></pre></li>
<li><p>AR (Android Runtime)  :<br> 在API&gt;=21的机器上，每个app都是一个AR 实例，这些实例通过DEX文件执行；AR的功能主要包括：</p>
<pre><code>a. AOT预编译  JIT 实时编译
b. 提升GC性能
c. 更好的debug支持

针对AR优化过的程序可以在低版本Android Dalvik虚拟机上获得性能优化，反之不成立
</code></pre></li>
<li>Native C/C++ Libraries<br> 出于性能考量，Android很多原生组件和服务都用到了native c/cpp的代码<pre><code>open GL 的2D 3D绘图基本都是用native api编写
如若需要，应用也可以通过Android NDK编写代码，调用native API
</code></pre></li>
<li>Java API FrameWork<pre><code>Android OS的整个功能集， JAVA编写
包含各组件、管理工具
</code></pre></li>
<li>应用层</li>
</ol>
<hr>
<p>识别二维码，关注公众号“夕识”<br><img src="http://upload-images.jianshu.io/upload_images/1481332-c461a8ddbf8cf08e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Architecture/">Architecture</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-技术/Android/【Android】应用架构演进"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/03/09/技术/Android/【Android】应用架构演进/">应用架构演进</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/03/09/技术/Android/【Android】应用架构演进/" class="article-date">
	  <time datetime="2018-03-08T16:35:35.000Z" itemprop="datePublished">2018-03-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/技术/">技术</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>预则立<br>应用演进过程中可能出现混乱局面，对架构的考量应该放在项目开始之前<br>参考：<br><a href="http://blog.spinytech.com/2016/12/28/android_modularization/" target="_blank" rel="noopener">Android架构思考(模块化、多进程)</a></p>
</blockquote>
<blockquote>
<p>适用范围：中型项目，小项目就不需要杀鸡用牛刀了</p>
</blockquote>
<hr>
<p>不进行设计时应用可能出现极度混乱的局面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-75c426d6709ddced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>跳过广受诟病的插件化思路，考虑应用<strong>路由框架</strong>设计<strong>组件化</strong>框架：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-782c8d1af71d2448.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="路由-1.png"></p>
<blockquote>
<p>这样的路由框架，在模块解耦的同时，提高了模块的可测性和复用性。<br><img src="http://upload-images.jianshu.io/upload_images/1481332-07c676326694ac24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="路由-3.png"><br>还可以在router与各路由之间加入 Common-Base层，作为公共library：<br><img src="http://upload-images.jianshu.io/upload_images/1481332-f7692235ff980e2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="路由-Common Base.png"></p>
</blockquote>
<p>在调用API时，路由机制的调用时序图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-4250238e45f0a1f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Router时序图.png"></p>
<p>这样的路由架构存在一个访问域问题，在多进程时需要进行格外处理</p>
<blockquote>
<p>多进程优势：</p>
<ol>
<li>独立各进程；</li>
<li>提高内存控制权；</li>
<li>模块解耦</li>
<li>守护</li>
</ol>
</blockquote>
<p>Router是单例模式，在多进程时直接使用会在每个JVM实例中生成，跨进程时需要将Router链接起来：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-2b216709e992978b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多进程路由连接图.png"></p>
<p>这时，调用时序图层级就略微有点深了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-9366cc7cb9bb15d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="广域事件传递时序图.png"></p>
<blockquote>
<p><strong>总结</strong>：<br>路由架构可以高度解耦，提升可测试性，也便于项目组进行任务划分、并行开发；<br>缺点是调用层级略微有点深，会有一定的性能损耗，但与其带来的优势相比可以忽略；此设计也没有考虑到MVP架构设计的融合问题，需要考虑应用场景的引用和适度</p>
</blockquote>
<hr>
<p>关注公众号“夕识”，雕刻时光，雕刻思维<br><img src="http://upload-images.jianshu.io/upload_images/1481332-c461a8ddbf8cf08e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Architecture/">Architecture</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-技术/Android/【Android】declare-styleable-枚举format简介"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/03/09/技术/Android/【Android】declare-styleable-枚举format简介/">declare-styleable-枚举format简介</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/03/09/技术/Android/【Android】declare-styleable-枚举format简介/" class="article-date">
	  <time datetime="2018-03-08T16:35:35.000Z" itemprop="datePublished">2018-03-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/技术/">技术</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>旨：介绍styleable enum format的使用方法</p>
</blockquote>
<blockquote>
<p>技术含量：低<br>（项目中对字体的自定义类型较多，考虑将字体设置属性定义成styleable，方便直接在xml中设置）</p>
</blockquote>
<p>首先定义attr.xml中的styleable：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-11adc1f8df53f3dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="attr_define.png"></p>
<blockquote>
<p>Code Glance （类型设置为enum）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"Font"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"font_type"</span> <span class="attr">format</span>=<span class="string">"enum"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">"msyh"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">"unidream_led"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">"helvetica"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">"bank"</span> <span class="attr">value</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">"ping_fang"</span> <span class="attr">value</span>=<span class="string">"4"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">attr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>之后就可以在xml中直接利用font_type属性了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-a2fae41d6f9e84cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="attr_enum.png"></p>
<p>在具体的类中解析：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1481332-64bf23e9b4fd9a56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="attr_parse.png"></p>
<blockquote>
<p>Code Glance<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TypedArray ar = context.getTheme().obtainStyledAttributes(attrs, R.styleable.Font, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">    <span class="meta">@FontMaster</span>.Type</span><br><span class="line">    <span class="keyword">int</span> fontType = ar.getInteger(R.styleable.Font_type, FontMaster.Type.Default);</span><br><span class="line">    FontMaster.font(fontType).set(<span class="keyword">this</span>);</span><br><span class="line">    ar.recycle();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    FontMaster.font(FontMaster.Type.MSYH).set(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p>关注公众号“夕识”，雕刻时光，不负流年<br><img src="http://upload-images.jianshu.io/upload_images/1481332-c461a8ddbf8cf08e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>

</section>
        
      </div>
      
        <div align="center" style="margin-top: 30px;"><hr class="hr" style="margin:0px; height:3px;"></div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="/about/" target="_blank">KyleCe</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2015 - 2018 KyleCe All Rights Reserved.</p>

	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>


  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>


  <script src="/js/home.js"></script>










	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            KyleCe
          </div>
          <div class="panel-body">
            Copyright © 2018 KyleCe All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
</body>
</html>